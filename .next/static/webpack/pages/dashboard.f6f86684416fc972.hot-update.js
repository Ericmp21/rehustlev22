"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard",{

/***/ "(pages-dir-browser)/./lib/mongodb.js":
/*!************************!*\
  !*** ./lib/mongodb.js ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var mongoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mongoose */ \"(pages-dir-browser)/./node_modules/mongoose/dist/browser.umd.js\");\n/* harmony import */ var mongoose__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mongoose__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Check if we're on the client side\nconst isClient = \"object\" !== 'undefined';\n// Only access MONGODB_URI on the server side\nconst MONGODB_URI = !isClient ? process.env.MONGODB_URI : null;\n// Skip validation on client-side\nif (!isClient && !MONGODB_URI) {\n    throw new Error(\"Please define the MONGODB_URI\");\n}\n// Parse username from URI for logging purposes only\ntry {\n    if (MONGODB_URI.includes('@')) {\n        const credentialPart = MONGODB_URI.split('@')[0].split('//')[1];\n        if (credentialPart && credentialPart.includes(':')) {\n            const username = credentialPart.split(':')[0];\n            console.log(\"Using MongoDB with username: \".concat(username));\n        }\n    }\n} catch (error) {\n// Ignore parsing errors\n}\nlet cached = __webpack_require__.g.mongoose;\nif (!cached) {\n    cached = __webpack_require__.g.mongoose = {\n        conn: null,\n        promise: null\n    };\n}\nasync function dbConnect() {\n    // If we're on the client side, return a dummy connection that won't crash\n    if (isClient) {\n        console.log(\"Client-side MongoDB access attempted - using mock\");\n        return createMockMongoose();\n    }\n    if (cached.conn) {\n        console.log(\"Using cached database connection\");\n        return cached.conn;\n    }\n    if (!cached.promise) {\n        const opts = {\n            bufferCommands: false,\n            // Use these options for more reliable connection\n            serverSelectionTimeoutMS: 5000,\n            connectTimeoutMS: 10000\n        };\n        console.log(\"Connecting to MongoDB...\");\n        cached.promise = mongoose__WEBPACK_IMPORTED_MODULE_0___default().connect(MONGODB_URI, opts).then((mongoose)=>{\n            console.log(\"MongoDB connected successfully\");\n            return mongoose;\n        }).catch((error)=>{\n            console.error(\"MongoDB connection error:\", error);\n            // Return a \"mock mongoose\" that won't crash but won't do anything\n            // This allows the app to continue running without a database\n            return createMockMongoose();\n        });\n    }\n    try {\n        cached.conn = await cached.promise;\n        return cached.conn;\n    } catch (e) {\n        console.error(\"Error resolving MongoDB connection:\", e);\n        throw e;\n    }\n}\n// Creates a mock Mongoose that won't crash but won't do anything\n// Used as a fallback when MongoDB connection fails\nfunction createMockMongoose() {\n    console.warn(\"Using mock Mongoose (no database persistence)\");\n    // In-memory storage for collections\n    const collections = {};\n    // Initialize with empty collections\n    const knownCollections = [\n        'users',\n        'deals',\n        'accounts'\n    ];\n    knownCollections.forEach((name)=>{\n        collections[name] = [];\n    });\n    // Try to load from localStorage or global memory\n    if ( true && window.localStorage) {\n        knownCollections.forEach((name)=>{\n            try {\n                const data = localStorage.getItem(\"rehustle_\".concat(name));\n                if (data) {\n                    collections[name] = JSON.parse(data);\n                    console.log(\"Loaded \".concat(collections[name].length, \" items from localStorage for \").concat(name));\n                }\n            } catch (e) {\n                console.error(\"Error loading \".concat(name, \" from localStorage:\"), e);\n            }\n        });\n    } else if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g._localDbStorage) {\n        knownCollections.forEach((name)=>{\n            try {\n                const data = __webpack_require__.g._localDbStorage[\"rehustle_\".concat(name)];\n                if (data) {\n                    collections[name] = JSON.parse(data);\n                    console.log(\"Loaded \".concat(collections[name].length, \" items from server memory for \").concat(name));\n                }\n            } catch (e) {\n                console.error(\"Error loading \".concat(name, \" from server memory:\"), e);\n            }\n        });\n    }\n    // Save data helper\n    const saveCollection = (name, data)=>{\n        if ( true && window.localStorage) {\n            localStorage.setItem(\"rehustle_\".concat(name), JSON.stringify(data));\n        } else if (typeof __webpack_require__.g !== 'undefined') {\n            if (!__webpack_require__.g._localDbStorage) {\n                __webpack_require__.g._localDbStorage = {};\n            }\n            __webpack_require__.g._localDbStorage[\"rehustle_\".concat(name)] = JSON.stringify(data);\n        }\n    };\n    // Mock mongoose object with minimum required functionality\n    return {\n        // This is what we return from mongoose.connect()\n        connection: {\n            readyState: 1\n        },\n        models: {},\n        model: (name, schema)=>{\n            if (!collections[name]) {\n                collections[name] = [];\n            }\n            // Return a mock model that works with MongoDB-like queries\n            const model = {\n                findOne: async (query)=>{\n                    console.log(\"[MockDB] findOne in \".concat(name, \":\"), query);\n                    const found = collections[name].find((doc)=>Object.entries(query).every((param)=>{\n                            let [key, value] = param;\n                            return doc[key] === value;\n                        }));\n                    return found ? {\n                        ...found\n                    } : null;\n                },\n                find: async (query)=>{\n                    console.log(\"[MockDB] find in \".concat(name, \":\"), query);\n                    return collections[name].filter((doc)=>Object.entries(query).every((param)=>{\n                            let [key, value] = param;\n                            return doc[key] === value;\n                        }));\n                },\n                create: async (data)=>{\n                    console.log(\"[MockDB] create in \".concat(name, \":\"), data);\n                    const _id = \"mock_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substring(2, 8));\n                    const newDoc = {\n                        ...data,\n                        _id\n                    };\n                    collections[name].push(newDoc);\n                    saveCollection(name, collections[name]);\n                    return {\n                        ...newDoc\n                    };\n                },\n                findByIdAndUpdate: async (id, update, options)=>{\n                    console.log(\"[MockDB] findByIdAndUpdate in \".concat(name, \":\"), id, update);\n                    const index = collections[name].findIndex((doc)=>doc._id === id);\n                    if (index === -1) {\n                        if (options === null || options === void 0 ? void 0 : options.upsert) {\n                            const newDoc = {\n                                ...update,\n                                _id: id\n                            };\n                            collections[name].push(newDoc);\n                            saveCollection(name, collections[name]);\n                            return newDoc;\n                        }\n                        return null;\n                    }\n                    // Apply updates\n                    if (update.$set) {\n                        collections[name][index] = {\n                            ...collections[name][index],\n                            ...update.$set\n                        };\n                    } else {\n                        // Direct update\n                        collections[name][index] = {\n                            ...collections[name][index],\n                            ...update\n                        };\n                    }\n                    saveCollection(name, collections[name]);\n                    return {\n                        ...collections[name][index]\n                    };\n                },\n                updateOne: async (filter, update)=>{\n                    console.log(\"[MockDB] updateOne in \".concat(name, \":\"), filter, update);\n                    const index = collections[name].findIndex((doc)=>Object.entries(filter).every((param)=>{\n                            let [key, value] = param;\n                            return doc[key] === value;\n                        }));\n                    if (index !== -1) {\n                        if (update.$set) {\n                            collections[name][index] = {\n                                ...collections[name][index],\n                                ...update.$set\n                            };\n                        } else {\n                            collections[name][index] = {\n                                ...collections[name][index],\n                                ...update\n                            };\n                        }\n                        saveCollection(name, collections[name]);\n                        return {\n                            modifiedCount: 1,\n                            acknowledged: true\n                        };\n                    }\n                    return {\n                        modifiedCount: 0,\n                        acknowledged: true\n                    };\n                },\n                deleteOne: async (filter)=>{\n                    console.log(\"[MockDB] deleteOne in \".concat(name, \":\"), filter);\n                    const initialLength = collections[name].length;\n                    collections[name] = collections[name].filter((doc)=>!Object.entries(filter).every((param)=>{\n                            let [key, value] = param;\n                            return doc[key] === value;\n                        }));\n                    if (initialLength !== collections[name].length) {\n                        saveCollection(name, collections[name]);\n                    }\n                    return {\n                        deletedCount: initialLength - collections[name].length,\n                        acknowledged: true\n                    };\n                }\n            };\n            // Store in models cache\n            if (!this.models[name]) {\n                this.models[name] = model;\n            }\n            return model;\n        }\n    };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dbConnect);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTSxDQUFDTixDQUFBQSxNQUMzQyxDQUFDQyxPQUFPQyxPQUFPLENBQUNJLFFBQVFILEtBQUssQ0FBQztnQ0FBQyxDQUFDQyxLQUFLQyxNQUFNO21DQUFLTCxHQUFHLENBQUNJLElBQUksS0FBS0M7O29CQUcvRCxJQUFJd0Isa0JBQWtCckQsV0FBVyxDQUFDRyxLQUFLLENBQUNPLE1BQU0sRUFBRTt3QkFDOUNFLGVBQWVULE1BQU1ILFdBQVcsQ0FBQ0csS0FBSztvQkFDeEM7b0JBRUEsT0FBTzt3QkFBRW1ELGNBQWNELGdCQUFnQnJELFdBQVcsQ0FBQ0csS0FBSyxDQUFDTyxNQUFNO3dCQUFFeUMsY0FBYztvQkFBSztnQkFDdEY7WUFDRjtZQUVBLHdCQUF3QjtZQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDbEMsTUFBTSxDQUFDZCxLQUFLLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQ2MsTUFBTSxDQUFDZCxLQUFLLEdBQUdlO1lBQ3RCO1lBRUEsT0FBT0E7UUFDVDtJQUNGO0FBQ0Y7QUFFQSxpRUFBZTdCLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvbGliL21vbmdvZGIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vbmdvb3NlIGZyb20gXCJtb25nb29zZVwiO1xuXG4vLyBDaGVjayBpZiB3ZSdyZSBvbiB0aGUgY2xpZW50IHNpZGVcbmNvbnN0IGlzQ2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIE9ubHkgYWNjZXNzIE1PTkdPREJfVVJJIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuY29uc3QgTU9OR09EQl9VUkkgPSAhaXNDbGllbnQgPyBwcm9jZXNzLmVudi5NT05HT0RCX1VSSSA6IG51bGw7XG5cbi8vIFNraXAgdmFsaWRhdGlvbiBvbiBjbGllbnQtc2lkZVxuaWYgKCFpc0NsaWVudCAmJiAhTU9OR09EQl9VUkkpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIGRlZmluZSB0aGUgTU9OR09EQl9VUklcIik7XG59XG5cbi8vIFBhcnNlIHVzZXJuYW1lIGZyb20gVVJJIGZvciBsb2dnaW5nIHB1cnBvc2VzIG9ubHlcbnRyeSB7XG4gIGlmIChNT05HT0RCX1VSSS5pbmNsdWRlcygnQCcpKSB7XG4gICAgY29uc3QgY3JlZGVudGlhbFBhcnQgPSBNT05HT0RCX1VSSS5zcGxpdCgnQCcpWzBdLnNwbGl0KCcvLycpWzFdO1xuICAgIGlmIChjcmVkZW50aWFsUGFydCAmJiBjcmVkZW50aWFsUGFydC5pbmNsdWRlcygnOicpKSB7XG4gICAgICBjb25zdCB1c2VybmFtZSA9IGNyZWRlbnRpYWxQYXJ0LnNwbGl0KCc6JylbMF07XG4gICAgICBjb25zb2xlLmxvZyhgVXNpbmcgTW9uZ29EQiB3aXRoIHVzZXJuYW1lOiAke3VzZXJuYW1lfWApO1xuICAgIH1cbiAgfVxufSBjYXRjaCAoZXJyb3IpIHtcbiAgLy8gSWdub3JlIHBhcnNpbmcgZXJyb3JzXG59XG5cbmxldCBjYWNoZWQgPSBnbG9iYWwubW9uZ29vc2U7XG5cbmlmICghY2FjaGVkKSB7XG4gIGNhY2hlZCA9IGdsb2JhbC5tb25nb29zZSA9IHsgY29ubjogbnVsbCwgcHJvbWlzZTogbnVsbCB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBkYkNvbm5lY3QoKSB7XG4gIC8vIElmIHdlJ3JlIG9uIHRoZSBjbGllbnQgc2lkZSwgcmV0dXJuIGEgZHVtbXkgY29ubmVjdGlvbiB0aGF0IHdvbid0IGNyYXNoXG4gIGlmIChpc0NsaWVudCkge1xuICAgIGNvbnNvbGUubG9nKFwiQ2xpZW50LXNpZGUgTW9uZ29EQiBhY2Nlc3MgYXR0ZW1wdGVkIC0gdXNpbmcgbW9ja1wiKTtcbiAgICByZXR1cm4gY3JlYXRlTW9ja01vbmdvb3NlKCk7XG4gIH1cbiAgXG4gIGlmIChjYWNoZWQuY29ubikge1xuICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgY2FjaGVkIGRhdGFiYXNlIGNvbm5lY3Rpb25cIik7XG4gICAgcmV0dXJuIGNhY2hlZC5jb25uO1xuICB9XG5cbiAgaWYgKCFjYWNoZWQucHJvbWlzZSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBidWZmZXJDb21tYW5kczogZmFsc2UsXG4gICAgICAvLyBVc2UgdGhlc2Ugb3B0aW9ucyBmb3IgbW9yZSByZWxpYWJsZSBjb25uZWN0aW9uXG4gICAgICBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVM6IDUwMDAsXG4gICAgICBjb25uZWN0VGltZW91dE1TOiAxMDAwMCxcbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coXCJDb25uZWN0aW5nIHRvIE1vbmdvREIuLi5cIik7XG4gICAgY2FjaGVkLnByb21pc2UgPSBtb25nb29zZS5jb25uZWN0KE1PTkdPREJfVVJJLCBvcHRzKVxuICAgICAgLnRoZW4oKG1vbmdvb3NlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTW9uZ29EQiBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICByZXR1cm4gbW9uZ29vc2U7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9uZ29EQiBjb25uZWN0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgIC8vIFJldHVybiBhIFwibW9jayBtb25nb29zZVwiIHRoYXQgd29uJ3QgY3Jhc2ggYnV0IHdvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBhcHAgdG8gY29udGludWUgcnVubmluZyB3aXRob3V0IGEgZGF0YWJhc2VcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1vY2tNb25nb29zZSgpO1xuICAgICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIGNhY2hlZC5jb25uID0gYXdhaXQgY2FjaGVkLnByb21pc2U7XG4gICAgcmV0dXJuIGNhY2hlZC5jb25uO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlc29sdmluZyBNb25nb0RCIGNvbm5lY3Rpb246XCIsIGUpO1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLy8gQ3JlYXRlcyBhIG1vY2sgTW9uZ29vc2UgdGhhdCB3b24ndCBjcmFzaCBidXQgd29uJ3QgZG8gYW55dGhpbmdcbi8vIFVzZWQgYXMgYSBmYWxsYmFjayB3aGVuIE1vbmdvREIgY29ubmVjdGlvbiBmYWlsc1xuZnVuY3Rpb24gY3JlYXRlTW9ja01vbmdvb3NlKCkge1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBtb2NrIE1vbmdvb3NlIChubyBkYXRhYmFzZSBwZXJzaXN0ZW5jZSlcIik7XG4gIFxuICAvLyBJbi1tZW1vcnkgc3RvcmFnZSBmb3IgY29sbGVjdGlvbnNcbiAgY29uc3QgY29sbGVjdGlvbnMgPSB7fTtcbiAgXG4gIC8vIEluaXRpYWxpemUgd2l0aCBlbXB0eSBjb2xsZWN0aW9uc1xuICBjb25zdCBrbm93bkNvbGxlY3Rpb25zID0gWyd1c2VycycsICdkZWFscycsICdhY2NvdW50cyddO1xuICBrbm93bkNvbGxlY3Rpb25zLmZvckVhY2gobmFtZSA9PiB7XG4gICAgY29sbGVjdGlvbnNbbmFtZV0gPSBbXTtcbiAgfSk7XG4gIFxuICAvLyBUcnkgdG8gbG9hZCBmcm9tIGxvY2FsU3RvcmFnZSBvciBnbG9iYWwgbWVtb3J5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAga25vd25Db2xsZWN0aW9ucy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGByZWh1c3RsZV8ke25hbWV9YCk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgY29sbGVjdGlvbnNbbmFtZV0gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgJHtjb2xsZWN0aW9uc1tuYW1lXS5sZW5ndGh9IGl0ZW1zIGZyb20gbG9jYWxTdG9yYWdlIGZvciAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgbG9hZGluZyAke25hbWV9IGZyb20gbG9jYWxTdG9yYWdlOmAsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5fbG9jYWxEYlN0b3JhZ2UpIHtcbiAgICBrbm93bkNvbGxlY3Rpb25zLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2xvYmFsLl9sb2NhbERiU3RvcmFnZVtgcmVodXN0bGVfJHtuYW1lfWBdO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGNvbGxlY3Rpb25zW25hbWVdID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgTG9hZGVkICR7Y29sbGVjdGlvbnNbbmFtZV0ubGVuZ3RofSBpdGVtcyBmcm9tIHNlcnZlciBtZW1vcnkgZm9yICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nICR7bmFtZX0gZnJvbSBzZXJ2ZXIgbWVtb3J5OmAsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIFxuICAvLyBTYXZlIGRhdGEgaGVscGVyXG4gIGNvbnN0IHNhdmVDb2xsZWN0aW9uID0gKG5hbWUsIGRhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYHJlaHVzdGxlXyR7bmFtZX1gLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKCFnbG9iYWwuX2xvY2FsRGJTdG9yYWdlKSB7XG4gICAgICAgIGdsb2JhbC5fbG9jYWxEYlN0b3JhZ2UgPSB7fTtcbiAgICAgIH1cbiAgICAgIGdsb2JhbC5fbG9jYWxEYlN0b3JhZ2VbYHJlaHVzdGxlXyR7bmFtZX1gXSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIE1vY2sgbW9uZ29vc2Ugb2JqZWN0IHdpdGggbWluaW11bSByZXF1aXJlZCBmdW5jdGlvbmFsaXR5XG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyBpcyB3aGF0IHdlIHJldHVybiBmcm9tIG1vbmdvb3NlLmNvbm5lY3QoKVxuICAgIGNvbm5lY3Rpb246IHtcbiAgICAgIHJlYWR5U3RhdGU6IDEsIC8vIENvbm5lY3RlZFxuICAgIH0sXG4gICAgbW9kZWxzOiB7fSxcbiAgICBtb2RlbDogKG5hbWUsIHNjaGVtYSkgPT4ge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uc1tuYW1lXSkge1xuICAgICAgICBjb2xsZWN0aW9uc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXR1cm4gYSBtb2NrIG1vZGVsIHRoYXQgd29ya3Mgd2l0aCBNb25nb0RCLWxpa2UgcXVlcmllc1xuICAgICAgY29uc3QgbW9kZWwgPSB7XG4gICAgICAgIGZpbmRPbmU6IGFzeW5jIChxdWVyeSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbTW9ja0RCXSBmaW5kT25lIGluICR7bmFtZX06YCwgcXVlcnkpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kID0gY29sbGVjdGlvbnNbbmFtZV0uZmluZChkb2MgPT4gXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhxdWVyeSkuZXZlcnkoKFtrZXksIHZhbHVlXSkgPT4gZG9jW2tleV0gPT09IHZhbHVlKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kID8gey4uLmZvdW5kfSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBmaW5kOiBhc3luYyAocXVlcnkpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW01vY2tEQl0gZmluZCBpbiAke25hbWV9OmAsIHF1ZXJ5KTtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbnNbbmFtZV0uZmlsdGVyKGRvYyA9PlxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMocXVlcnkpLmV2ZXJ5KChba2V5LCB2YWx1ZV0pID0+IGRvY1trZXldID09PSB2YWx1ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgY3JlYXRlOiBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbTW9ja0RCXSBjcmVhdGUgaW4gJHtuYW1lfTpgLCBkYXRhKTtcbiAgICAgICAgICBjb25zdCBfaWQgPSBgbW9ja18ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDgpfWA7XG4gICAgICAgICAgY29uc3QgbmV3RG9jID0geyAuLi5kYXRhLCBfaWQgfTtcbiAgICAgICAgICBjb2xsZWN0aW9uc1tuYW1lXS5wdXNoKG5ld0RvYyk7XG4gICAgICAgICAgc2F2ZUNvbGxlY3Rpb24obmFtZSwgY29sbGVjdGlvbnNbbmFtZV0pO1xuICAgICAgICAgIHJldHVybiB7IC4uLm5ld0RvYyB9O1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZmluZEJ5SWRBbmRVcGRhdGU6IGFzeW5jIChpZCwgdXBkYXRlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtNb2NrREJdIGZpbmRCeUlkQW5kVXBkYXRlIGluICR7bmFtZX06YCwgaWQsIHVwZGF0ZSk7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBjb2xsZWN0aW9uc1tuYW1lXS5maW5kSW5kZXgoZG9jID0+IGRvYy5faWQgPT09IGlkKTtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucz8udXBzZXJ0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0RvYyA9IHsgLi4udXBkYXRlLCBfaWQ6IGlkIH07XG4gICAgICAgICAgICAgIGNvbGxlY3Rpb25zW25hbWVdLnB1c2gobmV3RG9jKTtcbiAgICAgICAgICAgICAgc2F2ZUNvbGxlY3Rpb24obmFtZSwgY29sbGVjdGlvbnNbbmFtZV0pO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3RG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFwcGx5IHVwZGF0ZXNcbiAgICAgICAgICBpZiAodXBkYXRlLiRzZXQpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25zW25hbWVdW2luZGV4XSA9IHsgLi4uY29sbGVjdGlvbnNbbmFtZV1baW5kZXhdLCAuLi51cGRhdGUuJHNldCB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXJlY3QgdXBkYXRlXG4gICAgICAgICAgICBjb2xsZWN0aW9uc1tuYW1lXVtpbmRleF0gPSB7IC4uLmNvbGxlY3Rpb25zW25hbWVdW2luZGV4XSwgLi4udXBkYXRlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHNhdmVDb2xsZWN0aW9uKG5hbWUsIGNvbGxlY3Rpb25zW25hbWVdKTtcbiAgICAgICAgICByZXR1cm4geyAuLi5jb2xsZWN0aW9uc1tuYW1lXVtpbmRleF0gfTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHVwZGF0ZU9uZTogYXN5bmMgKGZpbHRlciwgdXBkYXRlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtNb2NrREJdIHVwZGF0ZU9uZSBpbiAke25hbWV9OmAsIGZpbHRlciwgdXBkYXRlKTtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbGxlY3Rpb25zW25hbWVdLmZpbmRJbmRleChkb2MgPT4gXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhmaWx0ZXIpLmV2ZXJ5KChba2V5LCB2YWx1ZV0pID0+IGRvY1trZXldID09PSB2YWx1ZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuJHNldCkge1xuICAgICAgICAgICAgICBjb2xsZWN0aW9uc1tuYW1lXVtpbmRleF0gPSB7IC4uLmNvbGxlY3Rpb25zW25hbWVdW2luZGV4XSwgLi4udXBkYXRlLiRzZXQgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbGxlY3Rpb25zW25hbWVdW2luZGV4XSA9IHsgLi4uY29sbGVjdGlvbnNbbmFtZV1baW5kZXhdLCAuLi51cGRhdGUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhdmVDb2xsZWN0aW9uKG5hbWUsIGNvbGxlY3Rpb25zW25hbWVdKTtcbiAgICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkQ291bnQ6IDEsIGFja25vd2xlZGdlZDogdHJ1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZENvdW50OiAwLCBhY2tub3dsZWRnZWQ6IHRydWUgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRlbGV0ZU9uZTogYXN5bmMgKGZpbHRlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbTW9ja0RCXSBkZWxldGVPbmUgaW4gJHtuYW1lfTpgLCBmaWx0ZXIpO1xuICAgICAgICAgIGNvbnN0IGluaXRpYWxMZW5ndGggPSBjb2xsZWN0aW9uc1tuYW1lXS5sZW5ndGg7XG4gICAgICAgICAgY29sbGVjdGlvbnNbbmFtZV0gPSBjb2xsZWN0aW9uc1tuYW1lXS5maWx0ZXIoZG9jID0+IFxuICAgICAgICAgICAgIU9iamVjdC5lbnRyaWVzKGZpbHRlcikuZXZlcnkoKFtrZXksIHZhbHVlXSkgPT4gZG9jW2tleV0gPT09IHZhbHVlKVxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGluaXRpYWxMZW5ndGggIT09IGNvbGxlY3Rpb25zW25hbWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgc2F2ZUNvbGxlY3Rpb24obmFtZSwgY29sbGVjdGlvbnNbbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4geyBkZWxldGVkQ291bnQ6IGluaXRpYWxMZW5ndGggLSBjb2xsZWN0aW9uc1tuYW1lXS5sZW5ndGgsIGFja25vd2xlZGdlZDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBTdG9yZSBpbiBtb2RlbHMgY2FjaGVcbiAgICAgIGlmICghdGhpcy5tb2RlbHNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5tb2RlbHNbbmFtZV0gPSBtb2RlbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGJDb25uZWN0OyJdLCJuYW1lcyI6WyJtb25nb29zZSIsImlzQ2xpZW50IiwiTU9OR09EQl9VUkkiLCJwcm9jZXNzIiwiZW52IiwiRXJyb3IiLCJpbmNsdWRlcyIsImNyZWRlbnRpYWxQYXJ0Iiwic3BsaXQiLCJ1c2VybmFtZSIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsImNhY2hlZCIsImdsb2JhbCIsImNvbm4iLCJwcm9taXNlIiwiZGJDb25uZWN0IiwiY3JlYXRlTW9ja01vbmdvb3NlIiwib3B0cyIsImJ1ZmZlckNvbW1hbmRzIiwic2VydmVyU2VsZWN0aW9uVGltZW91dE1TIiwiY29ubmVjdFRpbWVvdXRNUyIsImNvbm5lY3QiLCJ0aGVuIiwiY2F0Y2giLCJlIiwid2FybiIsImNvbGxlY3Rpb25zIiwia25vd25Db2xsZWN0aW9ucyIsImZvckVhY2giLCJuYW1lIiwid2luZG93IiwibG9jYWxTdG9yYWdlIiwiZGF0YSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJsZW5ndGgiLCJfbG9jYWxEYlN0b3JhZ2UiLCJzYXZlQ29sbGVjdGlvbiIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJjb25uZWN0aW9uIiwicmVhZHlTdGF0ZSIsIm1vZGVscyIsIm1vZGVsIiwic2NoZW1hIiwiZmluZE9uZSIsInF1ZXJ5IiwiZm91bmQiLCJmaW5kIiwiZG9jIiwiT2JqZWN0IiwiZW50cmllcyIsImV2ZXJ5Iiwia2V5IiwidmFsdWUiLCJmaWx0ZXIiLCJjcmVhdGUiLCJfaWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwibmV3RG9jIiwicHVzaCIsImZpbmRCeUlkQW5kVXBkYXRlIiwiaWQiLCJ1cGRhdGUiLCJvcHRpb25zIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJ1cHNlcnQiLCIkc2V0IiwidXBkYXRlT25lIiwibW9kaWZpZWRDb3VudCIsImFja25vd2xlZGdlZCIsImRlbGV0ZU9uZSIsImluaXRpYWxMZW5ndGgiLCJkZWxldGVkQ291bnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./lib/mongodb.js\n"));

/***/ })

});